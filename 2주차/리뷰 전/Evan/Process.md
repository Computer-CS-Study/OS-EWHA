Process is a program

프로세스의 문맥(context)

- CPU 수행 상태를 나타내는 하드웨어 문맥
    - 하드웨어 문맥
        - Program Counter
            - 해당 프로세스의 어디까지 실행했는가를 알기 위해서 저장한다.
        - 각종 register
- 프로세스의 주소 공간
    - 메모리와 관련된 주소 공간이다.
    - code
    - data
        - 지금 변수의 값들이 얼마인가
    - stack
        - 무슨 함수를 호출하고 있는가
- 프로세스 관련 커널 자료 구조
    - PCB(Process Cotrol Block)
        - 운영체제가 지금 컴퓨터 안에서 돌아가고 있는 프로세스를 관리하고 있다. 운영체제는 그 프로세스를 관리하기 위해서 PCB를 가지고 있다. 프로세스의 현재 상태를 알려면 프로세스 A와 CPU 상태도 알아야 하지만 이 커널 안에서 갖고 있는 프로세스의 대한 정보를 알아야한다.
    - Kernal stack
        - 프로세스가 실행이 되다가 운영체제에게 시스템 콜을 하면 PC가 커널의 어딘가를 가리키고 해당 부분을 실행할텐데 커널이 실행되면서 함수를 호출하는 구조일 것이고 이 때 커널 스택에 정보를 쌓아놓게 된다. 하지만 커널은 프로세스들이 공유 하는 코드라고도 볼 수 있다.
        - 이 커널이 누구의 부탁을 받느냐가 매번 다른데 프로세스 별로 저장해야하므로 커널 스택을 프로세스마다 별도로 두고 있다.
        - 프로세스의 현재 상태를 저장하려면 프로세스의 스택만으로는 부족하고 커널 스택에서 해당 프로세스의 커널 스택도 같이 봐야한다.
- 이 부분을 설명하는 이유는 결국 현대의 프로그래밍에서는 타임 쉐어링이 일어나고 멀티태스킹을 하려면 여러가지 프로세스의 정보를 저장할 수 있어야한다. 그래야 다음 인스트럭션(즉 다른 프로그램으로 다시 돌아왔을 때)을 실행할 때 정확한 지점부터 수행할 수 있다.

프로세스의 상태(Process State)

- 프로세스는 상태가 변경되며 수행된다.(CPU가 여러개인 상황은 논하지 않고 이 강의를 진행)
- Running
    - CPU를 잡고 있는 프로세스는 매 순간 하나일 것이다.
- Ready
    - 다른 프로세스가 CPU를 잡고 있는 동안 CPU를 기다리는 상태이다.
    - CPU는 디스크에 접근을 못하니 메모리에 해당 프로세스의 정보가 올라와있어야 한다.
        - 즉 보통은 레디라는건 다른 조건이 다 만족이 되고 CPU만 얻었을 때 인스트럭션을 수행할 수 있는 상태를 일컫는다.
- Blocked (wait, sleep)
    - 지금 CPU를 주어도 당장 인스트럭션을 수행할 수 없는 상태
        - process 자신이 요청한 event가 즉시 만족되지 않아 이를 기다리는 상태
            - 예를 들면 디스크에서 뭔가를 읽어와야 한다던가, 아니면 지금 IO 상태라던가.
        - 어떤 프로그램의 코드를 쓰려고 했는데 메모리에 올라와있지 않을 때(메모리에 모든 코드를 올려놓지 못하기 때문에 디스크에 내려가있을 때도 있음)
- 보통은 위의 3가지가 프로세스의 상태이고 경우에 따라서 아래의 2가지 개념을 추가로 설명할 수 있긴 함..
- New
    - 프로세스가 생성중인 상태
    - admitted ← 메모리에 올라가는 것을 허락하는 행위
- Terminated
    - 수행이 끝난 상태
    - 사실 이미 종료가 됐으면 프로세스가 아니다.
    - 보통은 끝나고 나면 정리하는 작업이 약간 남아있다. 이런 상태를 일컫는다.
- Suspended(Stopped)
    - 외부(중기 스케줄러, 사람)적인 이유로 프로세스의 수행이 정지된 상태
    - 프로세스는 통째로 디스크에 swap out 된다.
        - 이게 중기 스케쥴러가 들어오면서 하나의 상태가 추가됨.
- Blocked랑 Suspended랑은 엄연히 다름
    - 블락드는 자신이 요청해서 event가 만족되면 Ready 상태로 되는 것이고
    - 서스펜디드는 외부에서 레쥼해주어야 액티브
    - CPU 입장에서는 블락드, 러닝, 레디 이런걸 변경하는게 이 프로세스가 이 CPU에서 일을 못하는거지만 사실 다른데서 프로세스는 어쨌든 일을 하고 있다 IO라던지 뭐 대기라던지 하지만 서스펜디드는 프로세스 자체가 죽어있는 상태라고 생각하면 좋다.

![스크린샷 2022-11-07 오후 10.05.58.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/57972056-a7ad-4047-a9e6-114200688642/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-07_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.05.58.png)

![스크린샷 2022-11-07 오후 10.27.55.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f445bbbd-ae6d-4539-b468-594ddde0ed7c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-07_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.27.55.png)

프로세스가 생성이 되면 레디 상태로 전환 → 즉 CPU만 얻으면 바로 실행 가능(최소한의 메모리는 항상 가지고 있어야한다.) → 본인 차례가 되면 CPU를 얻어서 러닝 상태가 될 것이다. → IO를 하는 상태처럼 자진해서 웨이팅 상태로 넘어가거나 타이머 인터럽트가 들어와서 씨피유를 뺏기는 경우는 레디로 간다. → 러닝에서 정상적으로 종료되면 터미네이트로 넘어갈 것이다.

![스크린샷 2022-11-07 오후 11.02.01.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/839081a4-b381-4d4e-b6ed-320aaaa04fdb/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-07_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.02.01.png)

cpu는 빠르고 여럿이 공유하는 자원이다. 레디 큐에 있는 것들이 돌면서 하나씩 CPU를 점유함. 

러닝하다가 디스크의 프로세스를 써야할 때는 디스크 큐에 들어가서 줄을 서게 됨. 이 상태에서는 blocked가 됨

하드웨어 자원에 갈 때도 있지만 소프트웨어 자원에서 기다릴 때도 있다.

공유 데이터를 접근 할 때인데 어떤 프로세스가 해당 데이터를 접근 하고 있으면 리소스 큐에 줄 서고 프로세스가 Blocked 상태로 전환된다. → 프로세스는 오래 기다리는 상태가 되면 Blocked로 바뀐다.

이런 큐들은 운영체제 커널이 Data에 자료구조로 만들어놓고 한 곳에 모아놓는다.

Process Control Block (PCB)

- 운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보
- 다음의 구성요소를 가진다.(구조체로 유지)
    - OS가 관리상 사용하는 정보
        - Process state, Process Id
            - 레디나 블락드냐 뭐 등등의 상태고, 프로세스마다 유니크한 아이디
        - scheduling information, priority
            - 프로세스한테 CPU를 주기 위해서 가지고 있는 정보
            - 라운드로빈처럼 그려놨지만 우선순위에 따라서 처리한다.
    - CPU 수행 관련 하드웨어 값
        - Program counter, registers
    - 메모리 관련
        - code, data, stack의 위치 정보
    - 파일 관련
        - open file descriptors

![스크린샷 2022-11-07 오후 11.11.24.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/691f9a91-96af-4cdc-8046-2e247d31af59/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-07_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.11.24.png)

문맥교환 (Context Switch)

CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정

CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행

- CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장
- CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴

![스크린샷 2022-11-11 오후 1.39.37.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/afae421a-5fa8-41d3-a6c2-53f73b7a68e4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.39.37.png)

시스템 콜이나 인터럽트 발생 시 반드시 context switch가 일어나는 것은 아니다.

- 사용자 프로세스 하나로부터 다른 사용자 프로세스로 넘어갈 때를 말했음
- ISR = 인터럽트 서비스 루틴

![스크린샷 2022-11-11 오후 1.41.49.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a84ecd18-0834-4cd1-8027-eb00895d9aaf/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.41.49.png)

1의 경우도 당연히 문맥교환(user mode만 바꾼다고 되어있지만.._이 일어난다. 하지만 어떤 그 문맥교환의 레벨이 CPU단계이고 해당 컨텍스트의 일부를 PCB에 저장해야하지만 2의 경우를 문맥교환이라고 부르고 이 때의 부담이 훨씬 크다. (eg. cache memory flush) 오버헤드가 훨씬 적다.

프로세스를 스케줄링하기 위한 큐

- Job queue
    - 현재 시스템 내에 있는 모든 프로세스의 집함
- Ready queue
    - 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
- Device queue
    - IO 디바이스의 처리를 기다리는 프로세스의 집합

프로세스들은 각 큐들을 오가며 수행된다

![스크린샷 2022-11-11 오후 1.54.48.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/120e6ecd-b299-4d06-8205-5cebca555c0a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.54.48.png)

![스크린샷 2022-11-11 오후 2.00.57.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5c1252b8-7de0-4950-a5a8-fe3f3686d8f9/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.00.57.png)

스케쥴러

(여기서 설명하는건 디스크 스케쥴러는 아님)

- Long-term scheduler (장기 스케쥴러 또는 잡 스케쥴러)
    - 시작 프로세스 중 어떤 것들을 ready queue로 보낼지 결정
    - 프로세스에 memory(및 각종 자원)를 주는 문제
    - degree of Multiprogramming을 제어
        - 멀티프로그래밍은 메모리에 초점을 맞춘 단어
        - 메모리에 몇개의 프로세스를 올릴지를 뜻하는 개념
        - 몇 개의 프로세스가 올라가냐에 따라 컴퓨터의 성능이 달라지는거라 굉장히 중요한 이슈
        - 너무 적어도 안 좋고 너무 많아도 안 좋음
    - time sharing system에는 보통 장기 스케줄러가 없음 (무조건 ready)
        - 분명히 이 부분은 조정해야하는 부분인데 장기 스케쥴러는 우리의 일반적인 컴퓨터에 없다. 이 부분을 해결하는건 중기 스케줄러로 해결하고 있다.)
- Short-term scheduler (단기 스케쥴러 또는 CPU 스케쥴러)
    - 어떤 프로세스를 다음번에 running시킬지 결정
    - 프로세스에 CPU를 주는 문제
    - 충분히 빨라야 함(millisecond 단위)
- Medium-term scheduler (중기 스케쥴러 또는 Swapper)
    - 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄
    - 프로세스에게서 memory를 뺏는 문제
        - 장기 스케줄러는 시작하자마자 메모리에 자원을 주는 문제고 지금 컴퓨터는 메모리를 무조건 주긴 줌, 근데 너무 많이 올라가있으면 문제가 되니 디스크로 주기 위해서 뻿는 스케쥴링이다.
    - degree of Multiprogramming을 제어
        - 시스템 입장에서는 장기보다는 중기가 좀 더 이득임

![스크린샷 2022-11-11 오후 3.14.11.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1945ce96-8cfb-4502-bc17-6689db26b354/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.14.11.png)

운영체제가 관리상 사용자 프로세스 상태를 나눠놓고 관리하는 것이지 운영체제는 러닝이고 뭐고 없음 항상 러닝임 → 운영체제가 러닝하고 있다 x → 사용자 프로세스가 커널모드에서 러닝하고 있다.

점선 아랫 부분은 외부적인 요인으로 프로세스가 얼어붙은 상태 → 인액티브, 정지되어있음 → 꼭 레쥼을 해주어야 액티브가 됨.

쓰레드(lightweight process)

쓰레드는 프로세스 내부에 CPU 수행하는 단위.

![스크린샷 2022-11-11 오후 3.58.15.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/013edbf7-20ae-4498-8ab6-d7e4bebbe18f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.58.15.png)

- 쓰레드의 구성
    - program counter
    - register set
    - stack space
- Thread가 동료 thread와 공유하는 부분(= task)
    - code section
    - data section
    - OS resources
- 전통적인 개념의 heavyweight process는 하나의 thread를 가지고 있는 task로 볼 수 있다.

쓰레드를 쓰면 생기는 장점은

- 하나의 서버 쓰레드가 blocked 상태인 동안에도 태스크 내의 다른 스레드가 실행되어 빠른 처리가 가능하다.
- 동일한 일을 수행하는 다중 스레드가 협력하여 높은 처리율(throughput)과 성능 향상을 얻을 수 있다.
- 스레드를 사용하면 병렬성을 높일 수 있다.
    - CPU가 여러개 달린 컴퓨터에서만 얻을 수 있는 장점이다.
- 프로세스가 여러개 올라가지 않기 때문에 코드, 데이터의 메모리 영역을 줄일 수 있다.

 PCB

![스크린샷 2022-11-11 오후 10.58.00.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/26957333-974b-480d-bd95-ba18a72f4ef2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.58.00.png)

프로세스마다 하나의 PCB가 만들어진다. 프로세스가 하나기 때문에 PCB는 하나만 만들어짐

이 프로세스 안에 쓰레드가 여러개면 CPU 수행과 관련된 정보만 각각 Thread마다 카피를 갖고 있게 됨 그 정보가 Program counter, registers이다.

![스크린샷 2022-11-11 오후 11.01.13.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ad4c3173-215c-4538-ac3a-f9050e160bb0/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.01.13.png)

쓰레드를 쓰는 장점은 4가지 정도이다.

- 응답성 (Responsiveness)
    - 사용자 입장에서 빠르다.
        - 하나의 쓰레드가 블락 됐을 때(io 인터럽트가 일어났을 때) 다른 쓰레드가 그리는 작업을 계속한다.
- 자원 공유 (Resource Sharing)
    - 코드, 데이터 프로세스의 자원을 공유할 수 있음
    - CPU 수행 단위만 별도로 둔다.
- 경제성 (Economy)
    - 프로세스를 하나 만드는 것은 오버헤드가 상당히 크다. 하지만 프로세스 하나 안에다가 쓰레드를 추가하는 것은 오버헤드가 그리 크지 않다.
    - 프로세스를 이동하면서 문맥 교환 시 오버헤드가 큰데 CPU 안에서 thread를 옮기는 것은 그리 어렵지 않다. 왜냐하면 같은 메모리 공간 안에서 움직이기 때문에 PCB에 저장해야하는 이슈가 적다.
- Multi Processor 아키텍쳐의 유틸성 (Utilization of Multi Processor Architecture)
    - 각각의 쓰레드가 서로 다른 CPU에서도 병렬적으로 효율적으로 일할 수 있다.

쓰레드의 구현

→ 약간의 개념만 알고 지나가자

- 어떤 쓰레드는 운영체제 커널의 지원을 받고 있다. → 커널 쓰레드
    - 쓰레드가 여러개 있다는 것을 운영체제 커널이 알고 있음
    - 하나의 쓰레드에서 다른 쓰레드로 CPU가 넘어가는 것도 커널이 CPU 스케쥴링 하듯이 넘겨준다.
- 다른 것들은 라이브러리의 지원을 받고 있다. → 유저 쓰레드
    - 프로세스 안에 쓰레드가 여러개 있다는 것을 운영체제는 모른다.
    - 유저 프로그램이 스스로 여러개의 쓰레드를 관리하는 것이다.
    - 커널이 볼 때는 일반적인 프로세스로 보임
    - 프로세스가 cpu 수행단위를 알아서 나누고 관리하는 것이라서 약간의 제한점이 있을 수 있다.
- 어떤 쓰레드는 리얼타임을 지원하는 쓰레드도 있다.
