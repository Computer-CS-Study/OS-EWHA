## DeadLock

교착상태


일련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태를 말함

자원은 하드웨어, 소프트웨어 모두 포함함

프로세스가 자원을 사용하는 절차

1. 요청
2. 획득
3. 사용
4. 반납


Deadlock발생의 조건

- Mutual exclusion(상호배제)
    - 매 순간 하나의 프로세스만
- No preemption(비선점)
    - 강제로 빼앗기지 않음
- Hold and wait(보유대기)
    - 자원을 가진 프로세스가 자원을 놓지 않고 계속 소유
- Circular wait(순환대기)

자원할당그래프 → 데드락이 발생했는지 알아보는 그래프

그래프에 사이클이 없으면 deadlock 아님. (화살표를 따라가보면 된다)

사이클이 있을 때 만약에 자원당 오직 하나만의 인스턴스가 존재한다면 무조건 데드락, 아니면 가능성있음



Deadlock의 처리방법

미연에 방지하는 방법

- Deadlock Prevention



    - 교착상태가 발생하는 4가지 조건중 어느하나가 만족되지 않도록 하는 것.
    - Mutual Exclusion
    - Hold and wait(자진반납으로 해결)
        - 프로세스가 시작될 때 필요한 자원을 모두 할당받게
        - 자원이 필요한 경우 보유 자원을 모두 놓고 다시 요청
    - No preemption
        - 자원을 빼앗을 수 있도록
        - cpu, memory는 상태를 저장하고 restore를 할 수 있는 자원에서 주로 사용함
    - Circular wait
        - 자원의 순서를 정해 순서대로 자원 할당

  ⇒ 자원의 이용률이 저하되고, 성능이 나빠지고, starvation문제 발생


- Deadlock Avoidance
    - deadlock의 가능성이 없는 경우에만 자원 할당
    - 만약에 안전하지 않다면 자원의 여부가 있음에도 자원을 할당하지 않음


    

    - 자원에 대한 인스턴스가 1개일 때 데드락 피하는 방법
        - 평생에 한 번 어떤 자원을 요청할 수 있다의 의미 → 점섬 화살표
        - 최악의 상황 가정.



    - 자원에 대한 인스턴스가 여러개일 경우





        - 최대 요청을 하면 현재 가용자원에서 처리가 안되기 때문에 넘겨주지 않음

---

deadlock이 발생하도록 냅둠

- Deadlock Detection and recovery

  - 자원이 1개일 경우 자원할당 그래프에서 자원을 없애고 그래프를 그릴 수 있음 → wait-for그래프
  - 데드락 발생을 허용하되, 그에 대한 detection 루틴을 두어 발견시 recover
    - recovery 방법(process termination)
      - 데드락 프로세스에 있는 프로세스를 모두 없애는
      - 데드락 프로세스에 있는 프로세스에서 1개씩 제거해서 데드락이 해결되었는지 체크
    - resource preemption
      - 자원을 빼앗을 프로세스를 선정해서 데드락 해결
      - starvation문제 발생, 자원을 뺏는 패턴을 계속 바꿔가며 처리, 비용만 최소가 아니라 몇 번 빼앗겼는지 등을 체크해 해결해야 함

- Deadlock Ignorance

  - 현대의 대부분 os가 해당방식으로 처리
  - 사용자가 처리

데드락이 자주 발생하는 이벤트가 아니기에, 미연에 방지하기 위해 훨씬 더 많은 오버헤드를 들이는 것이 현대적인 시스템에서는 비효율적임