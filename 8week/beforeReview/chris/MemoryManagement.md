## 메모리 관리

메모리 → 주소를 통해 접근하는 매체

주소라 함은 2가지로 볼 수 있음


1. 논리적 주소(가상주소)
    1. 프로세스마다 가지고 있는 독립적인 주소 공간
    2. 각 프로세스마다 0번지부터 시작
2. 물리적 주소
    1. 메모리에 실제로 올가는 주소

주소를 결정하는것 ⇒ 주소 바인딩이라 함

→ 어떤 프로그램이 물리적인 메모리 어디로 올라갈지 메모리 주소를 결정하는 것을 말함

symbolic address ⇒ 프로그래머 입장에서의 주소

→ 컴파일이 되면 Logical address → 실행이 되려면 물리적 주소에 올라가야 하기 때문에 주소변환이 일어난다

언제 주소변환이 일어나는가?


1. compile time binding
    1. 컴파일시 주소변환 일어남
    2. 현대에는 사용하지 않음
    3. 컴퓨터에서 1개의 프로그램만 실행되던 시기에는 컴파일시 미리 물리적인 주소를 결정해서 처리 가능했다.
    4. 컴파일러는 절대코드를 생성한다. 결국 물리적 주소를 변경하려면 새로 컴파일 해야한다.
2. load time binding
    1. 실행이 시작되어 메모리에 올라갈 때
    2. 실행시에 어느위치든 올라갈 수 있는 코드
3. execution time binding(run time binding)
    1. 프로세스가 시작된 이후에도 물리적 주소가 바뀔 수 있을 때
    2. load time binding과 같음. 그러나 실행중에 바뀔 수 있다
    3. cpu가 주소를 참조할 때 마다 binding을 점검해야 한다
        1. 따라서 하드웨어 지원이 필요함. (MMU)
    4. 현대의 시스템

cpu는 논리적주소를 바라본다. 만약 데이터가 필요해 요청을하면 물리적주소에서 논리적주소로 변환된 값을 사용한다.


주소변환을 지원하는 하드웨어

Memory-management Unit (MMU)


base register 와 limit register를 활용해 변환한다.

base register에다가 프로세스의 시작위치를 저장. 변환할 때는 논리적주소 + base register한 값을 물리적주소로 사용

limit register는 프로세스의 최대 메모리를 저장, (다른 프로그램이 존재하는 상황일 때 막기위한 방안)


logical address > limit register 일 경우 트랩에 걸림

trap이 걸리면 운영체제에게 cpu가 넘어간다(일종의 software interruptor)

### 용어

dynamic loading


메모리에 다 올리는 것이 아닌 동적으로 올림

운영체제와 관련없이 프로그래머가 직접 구현하는 방법임(os가 라이브러리형태로 제공해줌)

→ 근데 용어 자체를 섞어씀…

Overlays


역사적으로 다름…. 초창기 시스템에서 프로그래머가 직접 구현한 것. 운영체제가 제공해주지 않음

그래서 dynamic loading과는 다름

swapping


프로세스를 일시적으로 메모리에서 backing store(swap area)로 쫓아내는 것

쫓겨나는걸 swap out 반대는 swap in

너무 많은 프로그램이 메모리에 올라와있으면 느려지기 때문에 중기 스케줄러가 몇몇을 골라서 통쨰로 날려버림. 그래서 중기스케줄러를 swapper라고도 함

우선순위가 낮은 cpu를 swap out함

swapping이 제대로 되려면 run time binding(execution time binding)이 지원돼야 함

현대에 와서는 모두 쫓겨내는게 아니라 일부만 되는 것도 swap out되었다라고도 씀

Dynamic Linking


link ⇒ 여러 군데 존재하는 컴파일된 파일을 묶어 하나의 실행파일로 만드는 과정

프로그램이 실행하다가 라이브러리 호출하는 코드에 도달하게 되면 stub(라이브러리의 위치를 찾을 수 있는 소위 포인터)을 둔다.

반대되는 개념은 static linking인데 이거는 라이브러리가 실행파일 코드에 포함된다. 그래서 메모리 낭비가 발생…(각각의 프로세스에서 동일한 라이브러리를 사용한다면)

## 물리적인 메모리를 어떻게 관리할 것인가?


낮은주소영역에 운영체제 커널이 상주

높은주소영역에 사용자 프로그램이 올라감

사용자 프로그램 영역의 할당 방법

- Contiguous allocation(연속할당)
    - 각각의 프로세스가 메모리의 연속적인 공간에 적재되도록 한 것

연속할당 방법



- 고정분할방식
    - 물리적 메모리를 영구적 분할로 나눔
    - 낭비되는 메모리조각
        - 외부조각(분할이 작아서)
            - 프로그램이 들어갈 수 있는 공간임에도 작아서 사용안된 공간
        - 내부조각(분할이 커서)
            - 프로그램의 크기가 커서 분할된 할당이 되었지만 사용이 안되는 공간
- 가변 분할 방식
    - 프로그램이 실행될 때 마다 차곡차곡 메모리에 올리는 방식
    - 프로그램의 크기보다 작아서 할당이 되지 못한 공간이 발생 ⇒ 외부조각
    - 가변분할방식에서 프로그램 사이즈에 맞는 적절한 Hole을 찾는 문제가 발생

    

        - first fit
            - 최초로 찾아지는 hole 할당
        - best fit
            - 모든 hole을 찾아서 가장 알맞는 hole 할당
        - worst fit
            - 가장 큰 hole에 프로그램 할당, 이것 또한 모든 hole을 탐색해야 함

hole ⇒ 가용 메모리 공간

고정분할방식에서는 hole들이 생김

운영체제는 할당공간과 가용공간(hole)에 대한 정보들을 유지해야 함



hole들을 모두 합치는 방법 - compaction

비용이 많이드는 매우 복잡한 방법.

runtime binding이 지원돼야 가능 함

---

- Noncontiguous allocation(불연속할당)
    - 하나의 프로세스가 메모리의 여러 영역에 분산되어 올라감
        - Paging
        - Segmentation
        - PageSegmentation

paging


프로그램을 구성하는 주소공간을 같은 크기의 페이지로 자름. 페이지 단위로 물리적 메모리에 올리거나 backing store에 내려놓거나 처리함

→ hole의 크기가 균일하지 않는 문제 등이 필요하지 않음

대신에 주소변환이 복잡해짐. 시작주소만이 아니라 각각의 페이지가 물리적 메모리 어디에 올라가 있는지 알고 있어야 함.

segmentation

의미있는 단위로 자름.

code, data, stack일수도 있고 각각의 함수들로도 만들 수 있고 나름임

크기가 균일하지 않음

→ hole과 관련한 문제가 발생