## Paging

프로그램을 구성하는 주소공간이 동일한 크기의 페이지로 잘려져 있어, 필요에 따라 물리적 메모리에 어느 위치든 올라가 있는 방법

페이지별로 주소변환이 필요하기에 단순한 MMU로는 어려움(base register만으로 어려움)


따라서 주소변환을 위해 페이지 테이블이 필요

상대적 위치는 변하지 않는다. 즉 페이지 내에서의 offset은 주소변환에 영향주지 않음. 논리적인 페이지 번호를 단순히 물리적 페이지 번호로 바꾸고 offset을 함께 넘기면 변환되는 것

페이지 테이블이 어디있어야 하는가?

기본 MMU에서는 register 2개로 변환

프로그램마다 테이블이 별도로 존재해야하며 보통 4kb로 페이지가 나뉘기에 프로그램마다 백만개 정도의 페이지가 필요. 그래서 페이지 테이블을 memory에 집어 넣는다.


따라서

메모리 접근을 위해서는 주소 접근을 위해 메모리접근이 필요…

주소변환을 위한 페이지 테이블의 베이스 값과 리미트 값을 가지는 용도로 사용

PTBR은 base register

PTLR은 limit register로 처리

2번 접근해야하기에 오래걸리니까 별도의 하드웨어를 사용 ⇒ associative register 혹은 TLB라 불리는

메인메모리와 CPu사이에 존재하는 주소변환을 위한 계층


메인메모리에 빈번히 사용하는 데이터를 캐시메모리에 저장.

메모리주소변환을 위한 별도의 캐시를 두는데 이것이 TLB!

논리적주소를 물리적주소를 변환할 때 cpu는 먼저 TLB를 체크. 저장되어있으면 바로 주소변환(메모리 1번 접근), 없을 경우에는 Page table접근(메모리 2번 접근)

TLB는 전체 서치를해야하고 그러다보니 오래걸리니 associative register를(parellel하게 찾음) 사용해 주소변환

프로세스마다 페이지테이블은 별개로 존재.

TLB는 context switch 때 flush 된다.!!

### 2단계 페이지 테이블

페이지 테이블을 위한 공간을 줄이는 것이 목적


1단계 페이지 테이블을 사용하면 현대의 컴퓨터 32bit address를 고려했을 때 너무 많은 page table이 필요하게 된다


page number를 2가지 값을 가지고 있고, page offset도 가지고 있는 상태

첫번째 Page number를 사용해서 outer-page table에서 주소를 가져오고, 해당 주소에서 두번째 page number를 사용해서 2번째 테이블에서 주소를 가져오고, 가져온 주소와 page offset을 이용해 메모리에서 데이터를 가져온다

2번째 페이지테이블의 크기는 페이지 크기와 같음 ⇒ 테이블 자체가 페이지 어딘가에 들어가 있는 구조

page = 4KB  ⇒ 2의 12승

그렇다면 12비트만큼이 Offset에 필요함

실제 사용되는 테이블만 안쪽 테이블을 제대로 가리키고 있고 사용안되면 NULL처리 되어 있음

안쪽페이지 만들어지지 않기 때문에 공간 효율적