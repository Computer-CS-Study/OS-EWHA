# Process Manager

프로세스 생성(Process Creation)

- 부모 프로세스가 자식 프로세스를 생성
- 프로세스의 트리(계층 구조) 형성
- 프로세스는 자원을 필요로 함
    - 운영체제로부터 받는다
    - 부모와 공유한다.
- 자원의 공유
    - 부모와 자식이 모든 자원을 공유하는 모델
        - 보통은 공유하지 않고 경쟁하는 모델임(CPU 점유를 위해서)
    - 일부를 공유하는 모델
    - 전혀 공유하지 않는 모델
- 수행 (Execution)
    - 부모와 자식은 공존하며 수행되는 모델
    - 자식이 종료될 때까지 부모가 기다리는 모델
- 주소 공간(Adress space)
    - 자식은 부모의 공간을 복사함 (binary and OS data)
        - 기본적으로는 복제 생성
            - 리눅스나 일부 효율적인 것을 추구하는 OS는 공유할 수 있는 부분은 두고 생성한다.
            - Copy-on-Write(COW) 기법이라고 많이 씀.
                - write(내용이 바뀌는)가 발생했을 때 copy하겠다. → 통째로 카피하는 것도 아님.
        - 복제한 뒤 그 공간에 새로운 프로그램을 할당
    - 자식은 그 공간에 새로운 프로그램을 올림
- 유닉스의 예
    - fork() 시스템 콜이 새로운 프로세스를 생성
        - 부모를 그대로 복사 (OS data except PID + binary)
        - 주소 공간 할당
    - fork 다음에 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올린다.
    - 어떤 사용자 프로그램이 직접 할 수 없고 운영체제를 통해서 수행한다(시스템 콜)

프로세스 종료

- 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌 (exit) → 자발적 종료
    - 자식이 부모에게 output data를 보냄 (via wait)
        - 프로세스는 자식이 먼저 종료(트리 계층이라서 이게 아마 유리할듯 내 추측으로는)
    - 프로세스의 각종 자원들이 운영체제에게 반납됨
- 부모 프로세스가 자식의 수행을 종료시킴 (abort)
    - 자식이 할당 자원의 한계치를 넘어섬
    - 자식에게 할당된 태스크가 더 이상 필요하지 않음
    - 부모가 종료하는 경우
        - 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다.
        - 단계적인 종료

fork()시스템 콜

![스크린샷 2022-11-20 오후 5.45.50.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b8a3384b-a8b8-4b93-813f-c5a9992437ff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-20_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.45.50.png)

자식 프로세스는 부모 프로세스의 문맥을 그대로 복사하기 때문에 fork가 일어나고 자식 프로세스가 메인부터 시작하는게 아니다 → 프로그램 카운터가 if를 가리킬 차례이기 때문이다. → PCB도 그대로 복사해옴

복제를 할 때는 운영체제가 복제본을 만들어주면 자식과 부모를 구분함 → fork()의 리턴 밸류가 다름. 부모 프로세스는 양수의 값을 받게 됨 → 정확하게는 자식 프로세스의 pid를 받음 → 자식은 0을 받게 됨

exec() 시스템 콜

![스크린샷 2022-11-20 오후 5.57.44.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/34df3c1a-4f98-49e5-893a-628b9667b536/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-20_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.57.44.png)

다른 프로그램으로 바뀌도록 해준다. → 이전의 PCB에서 갖고 있는 기억을 잊어버리고 새로운 프로그램을 실행하게 됨. → 해당 프로그램의 시작 부분부터 시작함. → 기존의 프로세스로 되돌아올 수는 없다.

exec 이후의 코드는 실행 불가 → 다른 프로세스로 바껴버리기 때문에

wait() 시스템 콜

자식 프로세스가 다 될 때까지 부모프로세스가 잠들어있는다.

![스크린샷 2022-11-20 오후 7.51.08.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3a068e1d-1640-4b0f-9207-d737591efcdf/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-20_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.51.08.png)

exit() 시스템 콜

- 자발적 종료
    - 마지막 statement 수행 후 exit() 시스템 콜을 통해 호출
    - 프로그램에 명시적으로 적어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어줌
- 비자발적 종료
    - 부모 프로세스가 자식 프로세스를 강제 종료시킴
        - 자식 프로세스가 한계치를 넘어서는 자원 요청
        - 자식에게 할당된 태스크가 더 이상 필요하지 않음
    - 키보드로 kill, break 등을 친 경우
    - 부모가 종료하는 경우
        - 부모 프로세스가 종료하기 전에 자식들이 먼저 종료됨

프로세스 간 협력

- 독립적 프로세스
    - 프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함
- 협력 프로세스
    - 프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음

- 프로세스 간 협력 메커니즘 (IPC: interprocess Communication)
    - 메시지를 전달하는 방법
        - message passing: 커널을 통해 메시지 전달
            - 직접 전달할 방법은 없음. → 다이렉트와 인다이렉트가 인터페이스 측면에서 차이가 나는 것이지 직접 전달할 수는 없음
            
            ![스크린샷 2022-11-20 오후 8.07.47.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/401f4830-5bfe-4fd7-a2f9-676d5833fde8/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-20_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.07.47.png)
            
    - 주소 공간을 공유하는 방법
        - shared memory: 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory 메커니즘이 있음 → shared memory도 마음대로 만들 수 있는게 아님 → 커널에 시스템 콜을 통해 요청한 다음에 요청한 뒤 사용할 수 있다. → 연결된 뒤에는 두 프로세스 간의 책임이라서 서로 알아서 잘 써야함.
        - thread: thread는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 process를 구성하는 thread들 간에는 주소 공간을 공유하므로 협력이 가능
