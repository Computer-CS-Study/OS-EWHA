## FileSystem Implementation


최근에는 페이지캐쉬와 버퍼캐쉬를 합친 unified 버퍼 캐쉬를 사용한다

버퍼캐쉬 ⇒ 운영체제가 파일 입출력을 할 때 사용자 프로그램의 요청을 받아서 디스크에서 읽어온 내용을 전달하는 것 뿐만아니라, 자신의 버퍼캐시에 넣어놓고 읽어온 내용을 카피해서 넘겨줌. 다음번에 동일한 파일 데이터에대한 시스템 콜이 오면 디스크에서 가져오는게 아니라 버퍼캐시에 들고 있는 내용을 전달

⇒ 디스크에 하나의 블럭(sector) 512byte(disk i/o단위)

페이지캐쉬 ⇒ 프로세스의 주소공간을 구성하는 페이지가 swap area에 내려가있는가? 또는 페이지 캐쉬에 올라와있는가에 대한 내용

⇒ 4kb단위의 페이지 단위

⇒ 페이지 캐쉬의 단위가 더 큼, 그런데 unified 되면서 버퍼캐쉬도 페이지 캐쉬처럼 4kb 단위를 사용

### memory-mapped i/o

프로세스의 주소공간일부를 파일에 Mapping해버림 → 메모리 접근하는 연산을 이용해서 파일 입출력을 가능하게 함


read, write 요청이 들어오면 운영체제는 파일시스템에 접근해서 파일을 읽어온 후 버퍼캐쉬에 넣어두고 copy해서 전달

메모리맵드 아이오 또한 시스템 콜을 요청함. → 자신의 주소공간 중 일부를 파일에 매핑. → 파일 시스템에 접근해 버퍼캐쉬에 가져오는 것 같음 → 그러나 페이지 캐쉬에 카피해서 전달 → 사용자 프로그램이 자신의 페이지캐쉬에다가 메모리에 요청하듯이 입출력을 요청하면 그대로 처리됨 → 커널의 도움 필요하지 않음

⇒ 파일 입출력할 때 꼭 버퍼캐쉬를 타긴해야 함

반면 Unified buffer cash

버퍼캐쉬와 페이지캐쉬를 나눠두지 않고 필요에 따라 씀. 경로가 단순해짐


code부분은 메모리에 올라간다음에 쫓겨날 때 swap area로 swap out되지 않음, 왜냐면 code는 read only이기 때문에 파일 시스템에 파일 형태로 존재.

swap out될 때 파일에 수정된 내용이 쓰이면서 Out됨

→ memory mapped i/o의 대표적인 예

memory mapped i/o는 양쪽에서 쓸 경우 consistency 문제 생길 수 있음

disk i/o는 복제본이기 때문에 괜찮음