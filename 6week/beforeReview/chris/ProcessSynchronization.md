## Process synchronization

sempahores

변수는 정수값을 가진다.

연산은 2가지로 정의 된다.

- P
    - 세마포어 변수의 값을 양수일 때 1을 감소시키면서 자원을 획득하는 과정
- V
    - 자원을 반환하는 과정

자원이 1일경우는 뮤텍스로 활용.

→ busy & wait

1보다 큰 수 일 경우는 자원의 개수를 확인하는 용도로 활용

→ block & wakeup방식 구현 가능

synchroniztion관련한 3가지 문제

1. Bounded-Buffer(생산자-소비자 문제)




버퍼는 임시로 데이터를 저장하는 공간을 말함

버퍼의 크기가 유한 함

생산자 프로세스와 소비자 프로세스 2가지 프로세스가 있다.

이 때 각 프로세스는 여러개가 있는 상황

생산자 ⇒ 공유 버퍼에 데이터를 만들어 집어넣는 역할

소비자 ⇒ 데이터를 꺼내는 역할

문제:

- 생산자가 두개가 동시에 도착해서 같은 위치에 동시에 집어넣으면 문제 발생
    - 공유버퍼에 락을 걸어서 다른 프로세스의 접근을 막아 처리
    - 버퍼에 데이터를 넣는 작업이 끝나면 그 때 락을 푼다.
    - 소비자도 같은 문제가 발생함
- 버퍼가 유한하기 때문에 발생하는 문제, 버퍼가 다 찼을 때 또 새로운 생산자가 새로운 데이터를 넣고자 할 때
    - 자리가 날 때 까지 생산자는 대기 상태
    - 생산자 입장에서는 비어있는 버퍼가 카운팅 해야될 자원!
    - 소비자 입장에서도 만약에 모든 버퍼가 비어있다면 같은 문제 발생
        - 내용이 들어있는 버퍼가 카운팅 해야할 자원!

세마포어를 이용해 처리해야할 일!

- 공유버퍼 전체에 lock을 걸어 배타적 접근하도록
- 버퍼가 가득차거나 비었을 때 생산자 또는 소비자의 가용자원을 카운팅하는 세마포어 변수가 필요


semaphore full ⇒내용이 들어있는 개수

empty ⇒ 비어있는 개수

mutex ⇒ 공유버퍼에 1개만 접근할 수 있도록 하는 변수

1. Readers-Writers




공유 데이터를 DB로 본다.

이것 또한 읽어가는 프로세스와 쓰는 프로세스가 여럿 있다.

reader는 synchronization과 관련한 문제가 발생하지 않음(동시 가능, Lock불필요)

대신 writer는 문제 발생, 독점적으로 배타적으로 처리되어야 함


공유되어야 할 데이터는

readCount ⇒ db에 접근중이 reader의 수

DB⇒DB자체

동기화가 되어야 하는 변수는

semaphore mutex ⇒ readCount에 lock에 해당하는 변수(binary)

db ⇒ DB에 lock에 해당하는 semaphore 변수(binary)

읽을 때도 lock은 필요, 그런데 읽으려고 lock을 걸면 다른 reader가 발생했을 때 허용할 수 있어야 함 ⇒ readCount로 처리

근데 readcount도 공유변수라서, readCount에 대해서 lock을 걸 필요가 있다. 이 때 쓰이는 변수라 Mutex임!

→ writer는 오래 기다려야함… 모든 reader가 처리 후 unlock했을 때 writer가 그제서야 처리 가능 ==⇒ starvation!!

우선순위를 둬서 처리 가능

1. Dining-Philosophers




철학자 → 생각하는 일, 밥먹는 일 2가지 업무

배가 고파지면 젓가락을 집어서 밥을먹고 생각, 이후에 다시 젓가락을 두고 생각

밥을 먹기 위해서는 젓가락 두짝을 모두 잡아야 함.

deadlock의 가능성 존재

예를 들어 모든 철학자가 모두 배가 고파져서 왼쪽의 젓가락을 잡아버린다면 영원히 오른쪽 잡을 수 없게됨


해결법

- 4명의 철학자만 테이블에 동시에 앉을 수 있도록
- 젓가락을 두 개 모두 집을 수 있을 때만 젓가락 집을 수 있도록
- 짝수는 왼쪽부터 홀수는 오른쪽부터 잡도록

### Monitor


세마포어는 한 번의 실수가 모든 시스템에 치명적 영향을 미친다

검증도 어려움


모니터는

프로그래밍 언어 차원에서 synchronization을 해결하는 high-level sync construct이다.

공유데이터를 접근하기 위해서는 모티너로 정의된 내부의 프로시저를 통해서만 접근할 수 있도록 함

모니터 안에 공유데이터와, 공유데이터에 접근하는 프로시저를 정의하고, 외부에서 접근할 때 프로시저를 통해서 접근할 수 있다. 또한 모니터가 동시에 여러 프로시저가 실행이 되지 않도록 통제함. 모니터는 기본적으로 동시접근을 허락하지 않음

세마포어와 차이점은 lock을 걸 필요가 없다는 점이다.

모니터는 내부에 공유 데이터에 대한 선언을 하고, 데이터에 접근하기 위한 프로시저는 내부 함수로 구현함


lock을 걸 필요는 없지만 자원의 수 대한 변수는 여전히 필요

→ condition variable

모니터 내부에는 하나의 프로세스만 활성화 되기 떄문에 나머지 프로세느는 줄서서 대기해야 함

공유자원의 수가 없어서 대기해야 한다면 목적에 맞게 줄을 세우고, 반대의 상황에서는 큐에서 깨워서 실행시킨다.