# 운영체제 강의 19강

꼭 virtual memory에서만 replacement 전략이 사용되는 건 아님

### cache


한정된 빠른공간에 요청된 데이터를 저장했다가 요청시 캐쉬로 부터 직접 서비스 하는 방식

교체 알고리즘에서 삭제할 항목을 결정하는 일에 많은 시간이 걸리는 경우 실제 시스템에서 사용불가

보통 시간복잡도 1이나 logn 정도만 허용(LRU, LFU가 그러하듯이)

LRU, LFU는 운영체제가 CPU를 얻어 인스트럭션 하나하나로 처리하는 것임

그런데 만약에 메모리에 있는 페이지에 대해서는 운영체제에게 CPU가 넘어오지 않기 때문에

운영체제는 어떤페이지가 가장 최근에 참조되었는지, 어떤페이지가 참조횟수가 많은지 알 수 없음

결국 paging system은 사용할 수 없음

⇒ 결국 page fault인 경우만 os 관여


Clock 알고리즘

LRU의 근사 알고리즘

reference bit을 이용. 이미 메모리에 존재하는 페이지에 대해서 해당 페이지가 참조되면 페이지를 cpu로 읽어들이면서 레퍼런스빗을 1로 설정!

교체대상을 찾는 과정은 레퍼런스빗이 0인것을 찾을 때까지 포인터 이동, 만약에 1이면 0으로 바꾸고 이동

개선

modified bit(dirty bit)

어떤 페이지가 참조되는 건 write때 참조될 수도 있는것. 그 때 modified bit을 1로 처리

최근에 변경된 페이지(I/O를 동반하는 페이지)

써주고 쫓아내자는 느낌 ㅋㅋㅋ


각각의 프로그램에게 얼마만의 프레임을 할당할 것인가?

- equal
    - 모든 프로세스가 똑같음
- proportional
    - 프로세스 크기에 비례
- priority
    - 프로세스의 priority에 따라(cpu우선순위)


그러나 할당을 하지 않고 replacement를 사용하다보면 알아서 할당되는 효과가 있긴 함

어떤 프로그램이 메모리를 많이 필요로 하면 그 순간에는 메모리에 많이 올라올거임

굳이 미리 할당하지 않고 알아서 알고리즘을 활용하면 프로세스별로 메모리할당량이 조절됨

global replacement

- replace시에 다른 프로세스 프레임 가져올 수 있음
- working-set, pff알고리즘 사용

Local replacement

- 자신에게 할당된 프레임 내에서만 replacement

### Thrashing


Page fault가 아주 빈번한게 발생하는 상황

메모리에 동시에 올라와있는 프로그램이 많아질수록 cpu사용량이 높아지다가 일정 수준을 넘어서버리면 사용량이 떨어지는데 이때 thrashing발생

cpu는 사용량이 낮아질 때(Thrashing) 더 프로세스를 높여야 한다고 판단해 다른 프로세스를 추가함

따라서 동시에 메모리에 올라간 프로세스 수를 조절해줘야 한다

프로그램이 어느정도 메모리 확보를 할 수 있도록 하게 해야함

### Working-set Model


locality of reference

- 프로세스는 특정 시간동안 일정 장소만 집중적 참조함
- 집중적으로 참조되는 page들의 집합을 locality set이라 함

→ working set이라 함

어떤 프로그램이 실행되면서 그 순간에 메모리에 꼭 올라와있어야만 하는 (빈번히 참조되는) 그런 페이지들의 집합을 working-set이라 함

working-set모델에서는 process의 working set전체가 메모리에 올라와있어야 수행됨, 그렇지 않을 경우 모든 frame반납 후 swap out(suspend상태)


working-set 알고리즘

과거로부터 판단한다.

working set의 결정해야 하는데 이것을 window size로 판단한다. 윈도우라함은 관찰한 시간(델타)이라 할 수 있다. 어떤 time interval사이에 참조된 서로 다른 페이지들의 집합이 working set이 된다.


### Page Fault Frequency


현재시점에서 프로그램의 page-fault의 비율을 보고 비율의 상한값을 넘으면 frame을 더 할당하고 하한값 이하면 frame수를 줄이는 방법, 빈 프레임이 없으면 일부 프로세스를 swap out시킨다

페이지 사이즈의 결정


페이지 사이즈가 작으면 페이지 테이블 크기가 증가한다. 그러나 필요한 정보만 메모리에 올라와 메모리 이용이 효율적이긴 하다. 그러나 locality의 활용 측면에서 좋지 않다.

disk transfer의 효율성은 페이지 사이즈가 클수록 좋음. 디스크는 seek을 해야하는데, seek은 매우 오버헤드가 큰 작업.  많은 양의 뭉치를 읽어서 메모리에 올리는게 좋음

요즘 추세는 페이지 사이즈를 키운다.