프로세스의 문맥

현재 cpu의 수행 상태

프로그램이 실행의 어떤 흐름에서 문맥이라고 함은 그 실행의 중간을 탁 잘라봤을 때 어떻게 실행했는지, 현재 시점이 어떤 상태에 있는지를 나타내는 표현이 = 문맥

현재 상태를 나타내는 모든 정보를 문맥이라 함

- cpu와 관련된 하드웨어 문맥
    - 매순간 인스트럭션을 실행하는데, 현재 시점에 인스트럭션을 어디까지 실행했는가? 레지스터에 어떤 값이 들어있고, 현재 프로그램 카운터는 어디를 가리키고 있는지
- 메모리와 관련된 프로세스의 주소 공간
    - code, data, stack에 무엇이 들어있는가?
- 운영체제의 역할 중 하나는, 현재 프로세스들을 관리하는 역할을 하는데
    - 프로세스가 시작할 때마다 운영체제는 프로세스를 관리하기 위해서 자신의 데이터 영역에 자료구조를 두는데 이걸 PCB라 함
    - 이를 통해 프로세스에게 어느정도의 cpu를 메모리를 얼마나 줘야할지 관리
- 프로세스가 실행되다가 본인이 할 수 없는 요청을 할 때(시스템 콜) 커널의 콜을 실행하게되고 → 스택에 관련된 정보를 쌓아놓는다. 플

⇒ 멀티쉐어링, 타임셰어링이기 때문에 현재의 상태를 제대로 알아야 하는 것

그래야 다음번에 cpu를 잡았을 때 그 다음 시점부터 인스트럭션을 실행 가능!!

프로세스의 상태!

(현재 모든 가정은 cpu는 1개)

- 프로세스가 cpu를 잡고 있는 상태: running
- 프로세스가 cpu를 기다리고 있는 상태: ready
    - 당장 필요한 부분이 메모리에 올라와 있음(다른 모든 준비는 다 되어있음)
    - 레디 상태에 있는 프로세스들이 번갈아 실행되며 타임쉐어링 함
- 프로세스가 cpu가 있어도 instruction을 실행할 수 없는 상태: blocked(wait, sleep)
    - io와 같은 오래걸리는 작업을 할 때(디스크에서 파일을 읽어야할 때)

- 프로세스가 생성중인 상태: New
- 프로세스 수행이 끝난 상태: Terminated
    - 약간의 정리하는 작업이 남아있는 상태

PCB = 운영체제가 각 프로세스를 관리하기위해 프로세스당 유지하는 정보

- 운영체제가 관리상 사용하는 정보
    - 프로세스 상태(러닝, 블럭드 등등)
    - 프로세스 id
    - 스케줄링 우선순위 값 등
- 프로세스의 문맥을 표시하기 위한 정보
    - 어떤 레지스터 값을 넣어서 실행하고 있었는가
- 메모리 관련
    - 코드 데이터 스택의 위치정보
- 파일관련
    - 오픈하고 있는 파일

문맥교환!

cpu가 사용자 프로세스로부터 다른 사용자 프로세스로 넘어가는 것을 문맥교환이라 함

문맥교환될 때 cpu에 사용중이던 레지스터, 프로그램 카운터, 메모리 맵을 pcb에 넣어 둠 그리고 프로세스가 cpu를 가지면 다시 꺼내옴

시스템콜이나 인터럽트 발생시 반드시 문맥교환이 일어나는 것은 아님.

→ 사용자 프로세스로 부터 다른 사용자 프로세스로 넘어가는 것을 문맥교환이라 하기에

→ 이 때도 컨택스트의 일부를 pcb에 저장함

타이머 인터럽트 또는 i/o를 요청하는 시스템콜일 경우에는 문맥교환 발생

→ 오버헤드가 위의 경우보다 훨씬 큼

프로세스 큐

- 잡 큐
    - 현재 시스템 내에 있는 모든 프로세스의 집합
    - 레디큐와 디바이스큐 모두 포함
- 레디 큐
    - 메모리 내에 있으면서 프로세스가 레디 상태인 프로세스의 집합
    - 사실은 pcb를 줄세우는 것
- 디바이스 큐
    - io디바이스 처리를 기다리는 프로세스의 집합


스케줄러(순서를 정해주는)

- 단기 스케줄러(숏텀 스케줄러)
    - cpu스케줄러, ms단위
- 롱텀 스케줄러(잡 스케줄러)
    - 시작 프로세스중 어떤 것을 레디큐에 보낼지
    - 프로세스에 메모리를 주는 문제를 관할
    - 멀티프로그래밍의 정도를 제어(메모리에 동시에 여러개 프로그램이 올라가는 개념) → 메모리에 몇개의 프로세스가 올라가 있냐?의 의미
    - 우리가 사용하는 시스템에서는 어떤 프로그램이 시작되면 곧바로 메모리에 올라감…. 사실상 장기스케줄러 없음
- 미디엄텀 스케줄러 (swapper)
    - 일부 프로그램을 골라 메모리에서 통째로 쫓아냄 ㅋㅋㅋ
    - 일단 메모리에 다 올려놓고, 너무 과하다면 쫓아냄

현대의 운영체제에서는 중기스케줄러로 돌아가고 그래서 프로세스의 상태가 suspend라는게 추가됨(ready, blocked, running)

suspended는 cpu뿐만 아니라 외부에서 해당 프로세스를 강제로 정지시켜놓은 상태.

blocked vs suspended

블럭은 자신이 요청한 event를 기다리는

suspended는 외부에서 정지시킨 상태, 즉 외부에서 재개를 시켜줘야 된다. 그래야 runnig, ready, blocked가 된다.

→ 프로세스가 자기 코드를 실행하다가 시스템콜을 통해 운영체제의 코드를 실행해도 커널모드에서 러닝하고 있다라 하지 운영체제가 러닝한다라 하지 않음!!

블럭된 상태에서 서스펜드가 되었냐 레디 상태에서 서스펜드가 되었느냐가 또 다름