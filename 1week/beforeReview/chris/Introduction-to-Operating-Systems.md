os는 연결하는 계층이라 생각하면 된다.

좁은의미: kernel → 운영체제가 메모리에 상주하는 부분

넓은의미: 커널 + 주변 시스템 유틸리티 포함(메모리에 상주하지 않음)

운영체제의 목적

- 하드웨어의 효율적 관리 → 가장 중요한 목적
- 사용자가 컴퓨터를 쉽게 사용할 수 있도록

운영체제의 분류(요즘방식)

- 동시작업의 가능 여부
    - 단일 작업
    - 다중 작업(0)
- 사용자의 수
    - 단일 사용자
    - 다중 사용자(0)
- 처리방식
    - 일괄 처리(batch processing)
        - 작업을 일정량 모아서 한꺼번에 처리
    - 시분할 방식(time sharing) → 대부분 이거 씀(0)
        - 처리능력을 일정한 시간 단위로 분할하여 사용
    - 실시간
        - 특수한 목적이 있음
        - 정해진 시간 안에 반드시 처리되도록 하는 os

      → 장비가 실시간을 요하는 상황이 많이 생기면서 시분할 방식을 가지는 os에서도 어떻게 실시간성을 보장하느냐가 이슈


멀티프로그래밍 → 메모리에 여러 프로그램이 올라가 있음(메모리 측면을 강조)

타임쉐어링 → 시간을 공유

멀티프로세서 → 프로세서는 cpu를 지칭, 하나의 컴퓨터에 cpu가 여러개

- unix
    - 대형 컴퓨터를 위해
    - 멀티태스킹 가능, 여러 유저 사용 가능
    - 유닉스 이전에는 대부분 어셈블리어로 개발되어 굉장히 어려웠음
    - c언어를 만들어 unix를 만듦
    - 소스코드 공개 ㄷㄷ
    - 이식성이 좋음 → 컴퓨터 기계어에만 국한되지 않음, 다른 환경이라면 새롭게 컴파일하면 된다.
    - 리눅스 → 공개소프트웨어정신에 입각해 만든 유닉스 계열 운영체제, 누구나 사용 가능, 리눅스는 개인용 컴퓨터도 사용하기 좋은 특징을 가짐. (안드로이드도 리눅스 커널 사용)
- windows
    - 초기에 dos위에서 떴음
    - 개인용컴퓨터 pc를 위해
    - 처음에는 단일 사용자 및 단일 작업만 지원

운영체제의 구조

- cpu
    - cpu 스케줄링: 누구에게 cpu를 줄까 → 짧은 시간간격으로 줬다 뺐다,
- memory
    - 한정된 메모리를 어떻게 쪼개 쓰는가 → 적어도 cpu에서 원할하게 실행되게 하기 위해서 필요한 메모리 용량만큼은 할당 받을 수 있도록
    - 자주 사용된 데이터는 메모리에 오래 둠.
- disk
    - 파일을 어떻게 보관하는가?
    - 이것 또한 스케줄링이 필요
    - 디스크 헤드의 이동을 줄이는 방법으로 처리도 함
        - 이거 오랜만이네… 지문에서 풀었지
- i/o device
    - 매우 느림. 컴퓨터 내부와 어떻게 정보를 주고 받을 것인가. → 입출력 관리
        - 기본적으로 Interrupt로 관리. io장치가 cpu에 보고할 일이 있으면 인터럽트를 걸어 cpu에게 알려주고, cpu는 다음작업 전에 먼저 처리하는 순으로 작업

cpu는 너무 빨라서 어떻게 처리할까에 대한 문제라면

디스크는 헤드가 움직이기에 움직임에서 어떻게 효율적으로 처리하냐에 포인트