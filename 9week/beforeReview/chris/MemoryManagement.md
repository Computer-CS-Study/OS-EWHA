# 운영체제 강의 17강

### Page Table

다단계로도 가능

→ 테이블을 위한 공간을 줄일 수 있음

n단계 테이블이라면 데이터접근을 위해 n+1번 메모리에 접근해야 함


사실은 페이지테이블에 주소뿐만아니라 valid - invalid bit이 존재


사용되지 않는 영역에도 엔트리 필요.. Index접근을 하기 때문에 모든 entry 필요

→ 즉 사용 안되는 페이지라면 invalid bit으로 표시된다

invalid로 표시되는 때는

1. 프로세스가 해당 주소부분을 사용하지 않거나
2. 물리적인 메모리에 올라와있지 않고 swap area에 있을 때

protection bit

다른 프로세스가 내 페이지에 접근하는 건 애초에 불가능. 왜냐면 프로세스의 페이지 테이블에 접근했으면 본인의 페이지에 대해서만 주소변환 가능.

그러니까 다른 프로세스가 다른 페이지 접근권한에 대한 것이 아님.

⇒ 어떤 연산에 대한 접근권한에 대한 bit임

이 페이지에 대해 읽기 권한 또는 쓰기권한이 있느냐에 대한 연산에 대한 권한을 표시하기 위한 bit임

code = read-only

data = read/write

### Inverted Page Table


페이지 테이블 자체가 메모리 공간을 많이 차지하게 됨.. 각 프로세스마다 페이지 테이블 필요

시스템 안에 딱 1개의 페이지 테이블 존재

물리적인 메모리의 페이지 frame개수만큼 존재


물리적주소를 보고 논리적 주소를 알아내는 방법이긴 함..

논리적주소와 같은 테이블을 모두 찾아야함… 바로 접근이 아님.(엔트리 전부 검색 필요)

프로세스id 또한 필요. 왜냐면 시스템에 1개의 페이지 테이블이니까

오버헤드가 큼 → associative register를 사용해 병렬적으로 검사

### 공유할 수 있는 페이지

shared code === re-entrant code === pure code


만약에 같은 코드로 프로그램을 돌리는 경우, code는 같은 프로그램이기에 share 할 수 있음

share가 가능한 shared code인 경우 한 개의 copy만 메모리에 올림

page를 read-only로 세팅해야함!

shared code는 모든 프로세스의 동일한 논리주소에 위치해야한다.

*shared memory와는 다름, read/write가 가능했엇고, 여기는 code만 공유 (read-only인 상태)

### segmentation

의미단위로 쪼갬

물리적 메모리에는 세그먼트 단위로 올라감


세그먼트별로 주소변환을 해야하기에 segment table이 필요

logical address ⇒ segment-number와 얼마나 떨어져있냐에 대한 Offset을 가지고 있음

segment-table base-register 세그먼트 테이블의 시작위치

segment-table length register 세그먼트의 Length


limit = segment의 길이에 테이블엔트리에 가지고 있음

segment의 길이는 Offset으로 표현할 수 있는 비트 수 이상은 불가능


중간중간 사용되지 않는 작은공간이 생김

크기가 균일하지 않기 때문에 first-fit/best-fit을 사용해야 함, 외부조각 발생

의미 단위로 작업될 때 좋음

- 예를 들어 Protection할 때 의미단위로 권한부여할 때 좋음
- process sharing할 때도 효율적

세그먼트는 메모리의 일부분을 공유하거나 보안에 있어 효율적

논리주소 = 세그먼트 번호, offset으로 구현

페이지테이블에서는 엔트리가 미리 정해짐(프로세스의 주소공간이 가질 수 있는 최대영역만큼)

반면 세그먼트테이블의 엔트리 개수는 프로그램이 사용하는 세그먼트의 개수로 정해짐

테이블에서 limit과 base를 가져오면 base의 시작위치와 얼마나 떨어져있는가에 해당하는 offset을 더해주면 확인할 수 있음. limit을 활용해 Offset이 해당 값보다 크다면 trap(소프트웨어적 interrupt)를 건다


의미단위로 자르기 때문에 크기가 다름. 그래서 세그먼트의 길이(limit)를 담고 있어야 함.

페이징기법은 페이지의 개수가 백만개 이러니까 페이지테이블을 위한 메모리 공간 낭비가 심함

반면 세그먼트에서는 세그먼트의 개수가 작아 테이블을 위한 메모리낭비가 적음

세그먼트의 공유


shared segment는 같은 논리적인 주소가 같아야함. segment번호가 같아야 함!

### Paged Segmentation


세그먼트 하나가 여러개의 페이지로 구성됨 ⇒ allocation문제가 발생하지 않음

보안과 공유의 문제는 특정 세그먼트만 처리 가능, 의미단위는 세그먼트가 처리 + 물리적 메모리에는 페이지 처리

실제로는 세그먼트만 사용하는 메모리 시스템은 현실적으로 없음. 대부분 내부에는 페이징을 같이 사용중

논리주소는 세그먼트 번호와 offset으로 구성, (세그먼트번호, Offset)

먼저 세그먼트 테이블에서 페이지 테이블 시작 위치로의 주소변환, 해당 주소에서는 페이지테이블의 시작위치가 나옴

세그먼트당 페이지테이블 존재.

세그먼트 테이블의 세그먼트의 길이를 보면 페이지테이블의 entry개수를 알 수 있음

세그먼트offset은 세그먼트 내에서 얼마나 떨어져있냐의 offset이고 ⇒ 세그먼트 하나는 여러개의 페이지로 구성되기에 해당 offset을 쪼개서 앞부분은 페이지 번호, 뒷부분은 페이지 offset으로 활요

주소변환을 위한 운영체제의 역할은 없음. 주소변환은 하드웨어가 모두 처리.