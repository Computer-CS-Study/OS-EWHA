## process synchronization

10강 내용 remind

공유데이터의 동시접근일 때 데이터의 불일치 문제가 발생할 수 있다.

그래서 이 때 일관성 유지를 위해 순서를 정할 매커니즘이 필요하다.

### Race condition

여럿이 동시에 접근하는 상황을 말함

이것을 해결하기 위해 동시에 실행되는 프로세스들에 대해 process synchronization이 잘 되어야 한다.

### critical-section = 임계구역

공유데이터에 접근하는 코드를 말함

크리티컬섹션에 들어가기 전(lock)과 후에 코드를 통해 다른 프로세스에서 크리티컬 섹션이 실행되지 않도록 처리하는 알고리즘에 대해 배움

### 크리리컬 섹션 문제를 해결하기 위한 조건

Mutual Exclusion

- 배타적으로 접근해야..
- 어떤 프로세스가 크리티컬섹션에 있을 경우 다른 모든 프로세스는 크리티컬 섹션에 접근할 수 없어야 한다.

Progress

- 크리티컬 섹션에 아무도 위치하지 않을 때 들어가고자 하는 프로세스가 있으면 들어가게 해줘야 함

Bounded Waiting

- 기다리는 시간이 유한해야한다.
- starvation이 없어야 한다

### 어떻게 소프트웨어적으로 락을 걸고 풀 수 있는가

1. turn 변수의 사용

   turn 변수를 통해 크리티컬 섹션에 들어갈 차례가 누구인지 판단

    - mutual exclusion 조건 만족
    - progress 조건 만족 못함
        - critical section이 교대가 되도록만 처리되어있음
2. flag 변수의 사용

   flag list boolean[]인 변수

   본인이 크리티컬섹션에 들어가고자 한다는 의중을 표시

   각 프로세스에서 상대방이 깃발을 들고 있는지 체크.

   크리티컬섹션에서 나올 때는 false로 처리

   만약에 flag를 true를 설정 후 cpu를 빼았겼을경우 아무도 들어가지 못하는 문제가 생김

    - progress조건 만족 못함
3. 피터슨 알고리즘

   turn과 flag모두 사용

   먼저 프로세스는 flag를 true로 바꿈, 이후에 turn을 상대방으로 처리해줌

   둘 다 모두 flag가 true일 때는 turn으로 순서를 따지고, 아무도 flag가 없을 경우에는 바로 들어가도록.

   Busy waiting(=spin lock)문제

    - 만약 크리티컬 섹션에 못들어가는 상활일 경우에 cpu를 잡을경우에는 쓸 때 없이 while문에서 모두 다 쓰고 cpu를 반환할 것 → 비효율적

### Synchronization Hardware

읽으면서 동시에 쓰는 작업이 하나의 인스트럭션으로 가능하다면 해결될 문제

하드웨어적으로 고유의 인스트럭션이 있음

→ Test_and_set

그러니까 test와set이 하나의 원자단위로 작동되니까 인터럽트가 그 중간에 발생하지 못하니 문제가 생기지 않는다. 기존에 flag나 turn같은 경우는 set하고 인터럽트에 의해 뺏길 때 문제가 생겼는데, test_and_set은 그러지 않는다!!!

### Semaphores

추상자료형 ⇒ object와 operation으로 구성

논리적으로 정의하는 거지 어떻게 구현된지와는 별개임

semaphores도 추상자료형임.

integer variable은 자원의 개수를 말함

p연산: 변수(공유데이터)값을 획득하는 과정, lock을 거는 과정

→ 여전히 busy-wait문제는 생김

v연산: 다 사용하고 반납하는 과정, lock을 푸는 과정

1을 자원 개수로 설정하고 크리티컬 섹션에 접근할 때 P, 처리 후 나올 때 V

p와v를 어떻게 구현할지는 구현해야할 시스템에서 생각해야할 몫

추상자료형 형태로 제공되고 프로그래머는 semaphore를 통해 구현을 하면 된다.

busy-wait은 효율적이지 못함 = spin lock

block & wakeup방식의 구현이 필요 = sleep lock

→ lock을 못 얻으면 불필요하게 cpu를 사용하는게 아니라 sleep(block)시켜버림

L → 프로세스 대기 큐

내어줄때 (V일때) 변수가 0이하라면 기다리는 프로세스가 있다는 소리이고, 대기큐에서 꺼내서 깨워준다.

busy-wait의 변수는 자원의 개수를 말함

그러나 block & wakeup은 변수는 현재 상황을 말함(이것도 남아있는 자원의 개수를 말하긴 함), 프로세스를 깨워야하는지에 대한 정보를 담고있다고 할 수 있음. 음수거나 0이면 깨워야할 프로세스가 있다는 것.

block-wakeup이 더 효율적임

그러나 이 방식도 오버헤드가 존재. 만약에 임계구역 코드량이 짧다면 busy-wait이 효율적.

세마포어 변수 값이 0이나 1일 경우 ⇒ Binary세마포어

→ 주로 mutual exclusion(lock/unlock)에 사용

변수값이 0이상인 정수값일 경우 Counting세마포어

### Deadlock

S,Q 둘다 필요할 때, 서로 하나씩 쥐고 있을 때 문제가 생김

→ 자원을 획득하는 순서를 똑같이 맞춰주면 해결 가능. 먼저 S를 얻어야 하는 순서라면~~ 해결

### Starvation

특정한 프로세스가 자원을 할당받지 못하고 무한히 기다리는 문제

데드락도 일종의 starvation이라 할 수도 있음,