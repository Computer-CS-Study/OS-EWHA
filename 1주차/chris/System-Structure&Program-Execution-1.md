하드웨어의 동작에 관한 강의

cpu + memory = computer

하드디스크 또한 I/O 장치라고도 볼 수 있다

디바이스 컨트롤러들이 io디바이스에 붙어있어서 관련해서 처리한다, 그리고 이 때 작동하기위해서 메모리도 필요한데 이것을 로컬 버퍼라 한다.

cpu는 계속해서 메모리에 있는 instruction을 가져다 실행하고 그 다음 걸 실행하고 이런 식

cpu내부에는 저장을 할 수 있는 작은 공간이 있는데 이것을 레지스터라 한다.

cpu내부에는 mode bit이라는 것이 있는데 이것을 통해 현재 cpu에서 실행되는 것이 os인지 사용자 프로그램인지 구분해준다.

cpu에는 interrupt line이 붙어 있는데, 계속적인 메모리와 cpu사이의 인트럭션에서 하나의 인트럭션을 완료후 interrupt line을 체크한다. 이 때 interrupt line이 없으면 그 다음 메모리에 있는 instruction을 실행, 만약 있다면 cpu가 사용자프로그램으로부터 운영체제로 넘어가게 된다.

추가적으로 디바이스 컨트롤러 또한 interrupt을 걸고 cpu에게 알려주고 다음 instruction을 실행하기 전에 운영체제에게 넘기는 것.

timer는 프로그램에게 설정된 시간만큼 cpu를 넘겨주고, 만약 설정된 시간이 되면 cpu에 interrupt를 걸고 이후 cpu가 os에게 넘어가게 된다. (특정 프로그램이 독점하지 못하도록)

운영체제가 특정프로그램에세 cpu를 넘겨줄 때는 독점하지 못하도록 특정 시간을 정해서 넘겨준다. 이 시간이 timer에서 체크 후 0이되면 타이머 인터럽트를 통해 cpu를 운영체제로 넘김

운영체제가 cpu를 얻으면 그 다음 메모리에 있는 프로그램이 실행된다.

사용자 프로그램은 i/o에 직접 접근 불가, 오직 운영체제를 통해서만 접근 가능. 그래서 프로그램에서 io작업이 필요할 경우 스스로 cpu를 운영체제에게 넘긴다.

⇒ 20분 ~ 23분 정도

mode bit ⇒ 0이면 모니터모드 or 커널모드 = os코드 수행, 1이면 사용자 프로그램 수행

0일 경우에는 os가 하는거니 디바이스 컨트롤러며 메모리 모두 접근 가능

1일 경우에는 제한된 instruction만 cpu에서 실행(보안상)

timer 정해진 시간이 흐른 뒤 운영체제에게 제어권 넘어가도록

dma controller 메모리를 접근할 수 있는(cpu말고 또 접근할 수 있는 놈)

→ cpu는 계속 자기일을 하고, io의 로컬버퍼에 있는 정보를 dma가 직접 메모리에 복사해주고 처리가 완료되었음을 cpu에게 보고.

memory controller는 cpu와 dma의 접근을 정리(한 번에 접근해서 오류나지 않도록)

35분부터 전반적 설명

사용자 프로그램에서 커널에 요청할 때 system call이라 부른다.👇🏼 이것도 아래의 io가 필요할 때와 같음

사용자 프로그램이 io가 필요할 경우 운영체제에 요청하게되는데 이 때 소프트웨어적으로 직접 interrupt를 걸 수 있음, 이 때 cpu가 운영체제로 넘어가고 운영체제가 io에게 요청

→ 소프트웨어 인터럽트라 한다(트랩이라고도 함)

현대의 운영체제는 인터럽트에 의해 구동된다.라는 말을 씀. 운영체제는 cpu를 사용할 일이 없음. 인터럽트가 될 때 운영체제가 cpu를 사용하지 그렇지 않을 경우에는 사용자가 대부분 사용